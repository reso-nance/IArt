#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pynput import keyboard
from datetime import datetime
import time, pandas, numpy
import mchmm as mc

keysCurrentlyPressed = {}
observations = numpy.array([])
lastKeyPressed = None
keyboardListener = None
keyboardController = keyboard.Controller()
lastKeyPressedTime = datetime.now()
period = 10. # in ms
playThreeshold = 1.5 # inactivity time after which the generated sequence will play (in seconds)
playBuffer = numpy.array([])
lastKeyPlayed = None

def on_press(key):
    global keysCurrentlyPressed, lastKeyPressed, lastKeyPressedTime, playBuffer, observations
    try: keyPressed = key.char
    # ~ except AttributeError: keyPressed = str(key)
    except AttributeError: # clear observation on special keys
        playBuffer = numpy.array([])
        observations = numpy.array([])
        return
    if lastKeyPlayed and keyPressed == lastKeyPlayed : return # this keypress was generated by the script
    if keyPressed not in keysCurrentlyPressed : 
        # ~ print("pressed "+keyPressed)
        keysCurrentlyPressed.update({keyPressed:datetime.now()})
        lastKeyPressedTime = datetime.now()
    lastKeyPressed = keyPressed
    # ~ assert len(keysCurrentlyPressed) == 0, "keysCurrently pressed not empty : %s" % keysCurrentlyPressed

def on_release(key):
    global keysCurrentlyPressed, keyboardListener, observations
    if key == keyboard.Key.esc:
        getMarkovProbas(observations)
        keyboardListener.stop()
        raise SystemExit
    try: keyPressed = key.char
    # ~ except AttributeError: keyPressed = str(key)
    except AttributeError: return
    # ~ keyDuration = datetime.now() - keysCurrentlyPressed[keyPressed]
    # ~ keyDuration = keyDuration.total_seconds()
    if keyPressed in keysCurrentlyPressed : del keysCurrentlyPressed[keyPressed]
    # ~ print ("key {} released after {}s".format(key, keyDuration))

def getMarkovProbas(observations) :
    markovChain = mc.MarkovChain().from_data(observations)
    # ~ print (observations)
    print(pandas.DataFrame(markovChain.observed_p_matrix, index=markovChain.states, columns=markovChain.states, dtype=float))
    return markovChain.observed_p_matrix
    
if __name__ == '__main__':
    keyboardListener = keyboard.Listener(on_press=on_press, on_release=on_release)
    keyboardListener.start()
    
    while True :
        
        timeElapsedSinceKeyboard = datetime.now() - lastKeyPressedTime
        if timeElapsedSinceKeyboard.seconds > playThreeshold : # play mode, uninterrupted
            if len(playBuffer) == 0 : # nothing to play yet
                if len(observations) > 500 :
                    print(observations)
                    markovChain = mc.MarkovChain().from_data(observations)
                    ids, playBuffer = markovChain.simulate(10000, start=lastKeyPressed)
            else : # we are continuing to play previously computed predictions
                if playBuffer[0] == "0" : # this is a pause
                    print("PAUSE")
                    if lastKeyPlayed is not None : # we've pressed a key
                        keyboardController.release(lastKeyPlayed)
                        print("OFF_"+lastKeyPlayed)
                        lastKeyPlayed = None
                elif playBuffer[0] != lastKeyPlayed and lastKeyPlayed is not None : # were changing from one key to another
                    keyboardController.release(lastKeyPlayed)
                    print("OFF_"+lastKeyPlayed)
                    lastKeyPlayed = playBuffer[0]
                    keyboardController.press(playBuffer[0])
                    print("ON_"+lastKeyPlayed)
                elif lastKeyPlayed is None : # we are pressing a key coming from a pause
                    lastKeyPlayed = playBuffer[0]
                    keyboardController.press(playBuffer[0])
                    print("ON_"+lastKeyPlayed)
                    
                playBuffer = numpy.delete(playBuffer, 0)
                
                
        elif len(keysCurrentlyPressed) > 0 : # record mode : a key is pressed
            observations = numpy.append(observations, lastKeyPressed)
            if len(playBuffer) > 0 : playBuffer = numpy.array([])
        else : # record mode : nothing is pressed
            observations = numpy.append(observations, '0')
        
        if len(playBuffer) > 0 : time.sleep(period/1000)
        else : time.sleep(period/1000)

