#!/usr/bin/env python
# -*- coding: utf-8 -*-
#  
from pynput import keyboard
from datetime import datetime
import mchmm as mc
import time, numpy
import UI

monitoredKeys = ["q","z","s","e","d","f","t","g","y","h","u","j","k","o","l","p","m"]
keyToNote = {"0":"--","q":"do1","z":"do#1","s":"ré1","e":"mib1","d":"mi1","f":"fa","t":"fa#","g":"sol","y":"sol#","h":"la","u":"sib","j":"si","k":"do2","o":"do#2","l":"ré2","p":"mib2","m":"mi2"}
keysCurrentlyPressed = {}
observations = numpy.array([])
lastKeyPressed = None
keyboardListener = None
keyboardController = keyboard.Controller()
lastKeyPressedTime = datetime.now()
removeSilenceFromVisualisation = True
period = 10. # in ms
playThreeshold = 1.5 # inactivity time after which the generated sequence will play (in seconds)
playBuffer = numpy.array([])
lastKeyPlayed = None

if __name__ == '__main__':
    raise SystemExit("This keyboard file is not meant to be executed directly. It should be imported as a module.")
 

def on_press(key):
    global keysCurrentlyPressed, lastKeyPressed, lastKeyPressedTime, playBuffer, observations, monitoredKeys
    try: keyPressed = key.char
    except AttributeError: # clear observation on special keys
        playBuffer = numpy.array([])
        observations = numpy.array([])
        return
    if keyPressed not in monitoredKeys : return
    if lastKeyPlayed and keyPressed == lastKeyPlayed : return # this keypress was generated by the script
    if keyPressed not in keysCurrentlyPressed : 
        keysCurrentlyPressed.update({keyPressed:datetime.now()})
        lastKeyPressedTime = datetime.now()
    lastKeyPressed = keyPressed
    markovData = getMarkovProbas(observations)
    if markovData : UI.sendMarkovDataToUI(markovData)

def on_release(key):
    global keysCurrentlyPressed, keyboardListener, observations
    if key == keyboard.Key.esc:
        getMarkovProbas(observations)
        keyboardListener.stop()
        raise SystemExit
    try: keyPressed = key.char
    except AttributeError: return
    if keyPressed not in monitoredKeys : return
    if keyPressed in keysCurrentlyPressed : del keysCurrentlyPressed[keyPressed]

def getMarkovProbas(observations) :
    global keyToNote, removeSilenceFromVisualisation
    if removeSilenceFromVisualisation : observations = observations[observations != "0"]
    markovChain = mc.MarkovChain().from_data(observations)
    names = markovChain.states
    weights = markovChain.observed_p_matrix.tolist()
    # ~ weights = [[round(w, 2) for w in W] for W in weights] # round floats to 3 digits
    weights = [[w for w in W] for W in weights]
    names = [keyToNote[n] for n in names] # translate keystrokes into corresponding readable note names
    print("states :", names)
    print("probas :", weights)
    # ~ print(pandas.DataFrame(markovChain.observed_p_matrix, index=markovChain.states, columns=markovChain.states, dtype=float))
    if len(names) > 1 : return {"weights":weights, "names":names}
    else : return False

def listen() :
    global keyboardListener, observations,playBuffer, keyboardController, lastKeyPlayed, period, playThreeshold, lastKeyPressedTime
    keyboardListener = keyboard.Listener(on_press=on_press, on_release=on_release)
    keyboardListener.start()
    print("starting listening to keyboard events")

    while True :
        
        timeElapsedSinceKeyboard = datetime.now() - lastKeyPressedTime
        if timeElapsedSinceKeyboard.seconds > playThreeshold : # play mode, uninterrupted
            if len(playBuffer) == 0 : # nothing to play yet
                if len(observations) > 500 :
                    # ~ print(observations)
                    markovChain = mc.MarkovChain().from_data(observations)
                    ids, playBuffer = markovChain.simulate(10000, start=lastKeyPressed)
            else : # we are continuing to play previously computed predictions
                if playBuffer[0] == "0" : # this is a pause
                    print("PAUSE")
                    if lastKeyPlayed is not None : # we've pressed a key
                        keyboardController.release(lastKeyPlayed)
                        print("OFF_"+lastKeyPlayed)
                        lastKeyPlayed = None
                elif playBuffer[0] != lastKeyPlayed and lastKeyPlayed is not None : # were changing from one key to another
                    keyboardController.release(lastKeyPlayed)
                    print("OFF_"+lastKeyPlayed)
                    lastKeyPlayed = playBuffer[0]
                    keyboardController.press(playBuffer[0])
                    print("ON_"+lastKeyPlayed)
                elif lastKeyPlayed is None : # we are pressing a key coming from a pause
                    lastKeyPlayed = playBuffer[0]
                    keyboardController.press(playBuffer[0])
                    print("ON_"+lastKeyPlayed)
                    
                playBuffer = numpy.delete(playBuffer, 0)
                
                
        elif len(keysCurrentlyPressed) > 0 : # record mode : a key is pressed
            observations = numpy.append(observations, lastKeyPressed)
            if len(playBuffer) > 0 : playBuffer = numpy.array([])
        else : # record mode : nothing is pressed
            observations = numpy.append(observations, '0')
        
        if len(playBuffer) > 0 : time.sleep(period/1000)
        else : time.sleep(period/1000)

